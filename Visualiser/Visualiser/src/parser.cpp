#include <stdio.h>

#include "globals.hpp"

// Note: simulation uses doubles for maximum precision, but we want
// to use floats as the precision isn't need here and it's faster on the GPU.

float grid_x_start;
float grid_x_end;
float grid_y_start;
float grid_y_end;
float grid_z_start;
float grid_z_end;
uint64_t num_spheres;
struct sphere_s *spheres;

// This file reads data from the binary file generated by the simulation.
static FILE *bin_file;
static size_t bin_file_size;

static void read_grid_dims() {
	double temp;
	fread(&temp, sizeof(double), 1, bin_file);
	grid_x_start = (float)temp;
	fread(&temp, sizeof(double), 1, bin_file);
	grid_x_end = (float)temp;
	fread(&temp, sizeof(double), 1, bin_file);
	grid_y_start = (float)temp;
	fread(&temp, sizeof(double), 1, bin_file);
	grid_y_end = (float)temp;
	fread(&temp, sizeof(double), 1, bin_file);
	grid_z_start = (float)temp;
	fread(&temp, sizeof(double), 1, bin_file);
	grid_z_end = (float)temp;
}

// Loads the state of the spheres in the next iteration.
// Also peeks ahead to read when the following iteration occurs.
// The visualiser needs to know this information.
// Note: for this to work correctly the position file pointer should not be
// modified between calls.
// TODO: end of file
// TODO: radius and mass stay constant so these will be moved to the header eventually
int get_next_iteration_sphere_state() {
	uint64_t iter_num;
	fread(&iter_num, sizeof(uint64_t), 1, bin_file);
	double tempd;
	fread(&tempd, sizeof(double), 1, bin_file);
	simulation_time_of_last_event = (float)tempd;
	for (int i = 0; i < num_spheres; i++) {
		fread(&tempd, sizeof(double), 1, bin_file);
		spheres[i].vel.x = (float) tempd;
		fread(&tempd, sizeof(double), 1, bin_file);
		spheres[i].vel.y = (float)tempd;
		fread(&tempd, sizeof(double), 1, bin_file);
		spheres[i].vel.z = (float)tempd;
		fread(&tempd, sizeof(double), 1, bin_file);
		spheres[i].pos.x = (float)tempd;
		fread(&tempd, sizeof(double), 1, bin_file);
		spheres[i].pos.y = (float)tempd;
		fread(&tempd, sizeof(double), 1, bin_file);
		spheres[i].pos.z = (float)tempd;
		fread(&tempd, sizeof(double), 1, bin_file);
		spheres[i].radius = (float)tempd;
		fread(&tempd, sizeof(double), 1, bin_file);
		spheres[i].mass = (float)tempd;
	}
	if (ftell(bin_file) == bin_file_size) {
		return 1;
	}
	fseek(bin_file, 8, SEEK_CUR);
	fread(&tempd, sizeof(double), 1, bin_file);
	simulation_time_of_next_event = (float)tempd;
	fseek(bin_file, -16, SEEK_CUR);
	return 0;
}

int init_parser(char *fp) {
	bin_file = fopen(fp, "rb");
	if (bin_file == NULL) {
		printf("Error: cannot open binary file %s\n", fp);
		return -1;
	}
	fseek(bin_file, 0, SEEK_END); 
	bin_file_size = ftell(bin_file);
	fseek(bin_file, 0, SEEK_SET);
	read_grid_dims();
	fread(&num_spheres, sizeof(uint64_t), 1, bin_file);
	spheres = (struct sphere_s *) calloc(num_spheres, sizeof(struct sphere_s));
	get_next_iteration_sphere_state();
	return 0;
}